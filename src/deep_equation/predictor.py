# -*- coding: utf-8 -*-
"""Loading_Test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ydIOplv3KmJUGz6GaEMmm12uj9azNM41
"""

"""
Predictor interfaces for the Deep Learning challenge.
"""

from typing import List
from PIL import Image #
from numpy import asarray
import numpy as np
import torch
import torchvision
import matplotlib.pyplot as plt
from time import time

class BaseNet:
    """
    Base class that must be used as base interface to implement 
    the predictor using the model trained by the student.
    """

    def load_model(self, model_path):
        """
        Implement a method to load models given a model path.
        """
        pass

    def predict(
        self, 
        images_a: List, 
        images_b: List, 
        operators: List[str], 
        device: str = 'cpu'
    ) -> List[float]:
        """
        Make a batch prediction considering a mathematical operator 
        using digits from image_a and image_b.
        Instances from iamges_a, images_b, and operators are aligned:
            - images_a[0], images_b[0], operators[0] -> regards the 0-th input instance
        Args: 
            * images_a (List[PIL.Image]): List of RGB PIL Image of any size
            * images_b (List[PIL.Image]): List of RGB PIL Image of any size
            * operators (List[str]): List of mathematical operators from ['+', '-', '*', '/']
                - invalid options must return `None`
            * device: 'cpu' or 'cuda'
        Return: 
            * predicted_number (List[float]): the list of numbers representing the result of the equation from the inputs: 
                [{digit from image_a} {operator} {digit from image_b}]
        """
    # do your magic

    pass 


class RandomModel(BaseNet):
    """This is a dummy random classifier, it is not using the inputs
        it is just an example of the expected inputs and outputs
    """

    def load_model(self, model_path):
        """
        Method responsible for loading the model.
        If you need to download the model, 
        you can download and load it inside this method.
        """
        np.random.seed(42)

    def predict(
        self, images_a, images_b,
        operators, device = 'cpu'
    ) -> List[float]:

        predictions = []
        for image_a, image_b, operator in zip(images_a, images_b, operators):            
            random_prediction = np.random.uniform(-10, 100, size=1)[0]
            predictions.append(random_prediction)
        
        return predictions


class StudentModel(BaseNet):
    """
    TODO: THIS is the class you have to implement:
        load_model: method that loads your best model.
        predict: method that makes batch predictions.
    """

    # TODO
    def load_model(self, model_path:str="model.pt"):
        """
        Load the student's trained model.
        TODO: update the default `model_path` 
              to be the correct path for your best model!
        """
        import pickle
        self.the_model = torch.load(model_path)
        self.results = [-9, -8, -7, -6, -5, -4, -3, -2, -1, 0, 0.1111111111111111, 0.125, 0.14285714285714285, 0.16666666666666666, 0.2, 0.2222222222222222, 0.25, 0.2857142857142857, 0.3333333333333333, 0.375, 0.4, 0.42857142857142855, 0.4444444444444444, 0.5, 0.5555555555555556, 0.5714285714285714, 0.6, 0.625, 0.6666666666666666, 0.7142857142857143, 0.75, 0.7777777777777778, 0.8, 0.8333333333333334, 0.8571428571428571, 0.875, 0.8888888888888888, 1, 1.125, 1.1428571428571428, 1.1666666666666667, 1.2, 1.25, 1.2857142857142858, 1.3333333333333333, 1.4, 1.5, 1.6, 1.6666666666666667,
1.75, 1.8, 2.0, 2.25, 2.3333333333333335, 2.5, 2.6666666666666665, 3, 3.5, 4, 4.5, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 20, 21, 24, 25, 27, 28, 30, 32, 35, 36, 40, 42, 45, 48, 49, 54, 56, 63, 64, 72, 81, np.inf]
        self.fig = plt.figure(figsize=(2, 2))
        pass
    
    # TODO:
    def max_pool(self,img, factor: int):
        ds_img = np.full((img.shape[0] // factor, img.shape[1] // factor), -float('inf'), dtype=img.dtype)
        np.maximum.at(ds_img, (np.arange(img.shape[0])[:, None] // factor, np.arange(img.shape[1]) // factor), img)
        return ds_img

    def preprocess_image(self,img):
        img = img.convert('1') # convert image to black and white
        p = torchvision.transforms.Resize((28,28),interpolation=torchvision.transforms.InterpolationMode.BICUBIC)
        img = p(img)
        return asarray(img)

    def get_operation(self,arr):
        i = np.argmax(arr)
        if i == 0:
          return "+"
        elif i==1:
          return "-"
        elif i ==2:
          return "*"
        elif i ==3:
          return "/"
    
    def get_index_operation(self,operators):
        if operators == "+":
            r = 0
        elif operators == "-":
            r = 1
        elif operators == "*":
            r = 2
        elif operators == "/":
            r = 3
        return r 

    def print_digit(self,img,idx):
        image_size = 28
        data = img.reshape(1, image_size, image_size, 1)
        image = np.asarray(data).squeeze()
        self.fig.add_subplot(1, 2, idx)
        plt.imshow(image, cmap='gray_r');

    def predict(
        self, images_a, images_b,
        operators, device = 'cpu'
    ):
        """Implement this method to perform predictions 
        given a list of images_a, images_b and operators.
        """
        img1 = self.preprocess_image(images_a)
        img2 = self.preprocess_image(images_b)

        arr = np.array([])
        arr = np.append(arr,img1)
        arr = np.append(arr,img2)
        operator_arr = np.zeros(4)
        r = self.get_index_operation(operators)
        operator_arr[r] = 1
        arr = np.append(arr,operator_arr)
        img = arr
        img = torch.FloatTensor(img).view(1,1572)
        with torch.no_grad():
          logps = self.the_model(img)
        ps = torch.exp(logps)
        probab = list(ps.numpy()[0])
        predict_result = self.results[probab.index(max(probab))]
        print("Predicted Result =", predict_result)
        img1 = img.view(1572).numpy()[:28*28]
        img2 = img.view(1572).numpy()[28*28:-4]
        operation = img.view(1572).numpy()[-4:]
        print("Operation:",self.get_operation(operation))
        self.print_digit(img1,1)
        self.print_digit(img2,2)
        plt.show()
        return predict_result

images1 = [Image.open("7_3.jpg"),Image.open("7631.png"),Image.open("8030.png"),Image.open("8493.png")]
images2 = [Image.open("3_3.jpg"),Image.open("7631.png"),Image.open("8030.png"),Image.open("8493.png")]
ops = ["+","-","*","/"]
model = StudentModel()
model.load_model("model.pt")
predictions = []
for xa,xb,xc in zip(images1,images2,ops):
  result = model.predict(xa,xb,xc)
  predictions.append(result)

